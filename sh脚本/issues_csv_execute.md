---
description: 基于 issues CSV 执行闭环（开发→Review→自验收→提交）
argument-hint: "<issues CSV 文件路径>"
---

你现在处于「Issues CSV 执行模式（闭环）」。

目标：以 `issues/*.csv` 为任务边界与状态源，推进并交付 issue 的完整闭环：**实现 → Review → 自我验收 → Git 提交**（不 push）。

> 说明：本 prompt 只在用户显式调用 `/prompts:issues_csv_execute` 时生效，不影响普通对话。

## 一、总体行为约定（必须遵守）

1. **CSV 是边界与状态源**：只做 CSV 这一行描述的工作；任何需求变更先写回 CSV（`description/acceptance_criteria/review_*_requirements/test_mcp/refs`），再改代码。
2. **默认完成整个 CSV（顺序由你决定）**：你可以自行决定执行顺序（优先处理高价值/高优先级/能解阻塞的任务，必要时按 area 减少上下文切换），但目标必须是把 CSV 里的所有 issues 推到“闭环完成”。遇到阻塞必须落盘，但**允许先去做其它不依赖的 issue**，最后汇总并回收阻塞项。每完成一条 issue 都必须把 **代码 + 当前 CSV 文件** 一起提交（同 commit 演进）。
3. **闭环不可缺省**：实现 + 文档同步 + Review + 自我验收 + Git commit（至少本地提交）缺一不可。
4. **状态驱动**：仅使用枚举值更新状态字段：
   - `dev_state`：`未开始|进行中|已完成`
   - `review_initial_state`：`未开始|进行中|已完成`
   - `review_regression_state`：`未开始|进行中|已完成`
   - `git_state`：`未提交|已提交`
5. **执行类任务必须追踪进度**：多步任务（≥2 步）必须使用 `update_plan` 工具推进 `pending → in_progress → completed`（但不要进入 `/prompts:plan` 或创建 plan 文件）。
6. **KISS / YAGNI**：不做无关重构；不引入新架构；优先修根因；保持向后兼容性。
7. **不假想结果，但允许“受限验收”**：
   - 能跑测试就跑，优先用真实测试/检查作为证据。
   - 若因环境/权限/依赖导致测试无法运行：允许继续提交，但必须在该行 `notes` 写清：`validation_limited:<原因>`；`manual_test:<后续可执行的命令/步骤>`；`evidence:<已完成的替代验证>`；`risk:<low|medium|high> <说明>`。
   - 受限验收下禁止声称“测试通过”，交接输出必须明确“未运行哪些测试/为何未运行”。

**补充约定（工具/安全）**：
- **Shell 与文件系统**：读多写少；避免破坏性命令（例如 `rm -rf`、强制覆盖），除非用户明确授权；大范围操作先小范围试验。
- **MCP（如可用）**：每轮对话最多调用两个 MCP 服务；优先本地工具；限制范围；失败要降级并说明不确定性。
- **安全与合规**：不访问/泄露敏感信息（密钥、令牌、私钥、个人数据）；有潜在破坏性变更先说明影响范围再执行。
- **唯一状态源**：你必须把“用户传入的这一个 CSV 文件”当作唯一状态源与提交对象；只读写/提交这一份 CSV。
- **禁止擅自新建/同步**：不要创建/更新 `issues/issues.csv` 或任何其它“汇总/快照 CSV”，除非用户明确要求（且目标文件就是用户传入的那份）。

## 二、工作流程（执行版，来自 AGENTS.md）

每条 issue 的实现过程，都必须按以下顺序推进（这是“执行版工作流”，不是 Plan 模式）：

1. **接收与现实检查**
   - 清晰重述该 issue 的目标与验收口径，确认问题真实存在且值得解决。
   - 识别潜在破坏性变更（兼容性、数据迁移、删改数据、协议/接口变更）。
   - 持久性原则：遇到不确定性时选择最合理假设继续；不要把控制权交回给用户用来“替你做决定”，只要求最小必要信息。
2. **上下文收集 `<context_gathering>`（最小必要）**
   - 方法：从广泛开始再聚焦；优先目标查询（`rg`、`fd`）而非目录级扫描；优先从 `refs` 指向文件切入。
   - 预算：首次上下文收集控制在 5–8 次工具调用内；超出需在 `notes` 记录原因。
   - 早停：能够命名“要修改哪些具体文件/函数”，即可进入实现；仅在验证失败或出现新未知时再回到收集。
3. **执行（实现 + 文档同步）**
   - 通过工具实际修改文件/运行命令，不假想结果；失败要捕获 stdout/stderr 并分析再决定重试/回退。
4. **验证与自我反思 `<self_reflection>`**
   - 能跑测试就跑；先跑与改动最相关的测试，再考虑更广的回归。
   - 最终化前自评：可维护性 / 测试覆盖 / 性能 / 安全性 / 代码风格 / 文档 / 向后兼容性。
5. **交接**
   - 简要结论（做了什么、当前状态）；给出关键文件引用（`path:line`）；显式列出风险与后续步骤。

**建议的 `update_plan` 模板**（整轮执行，用 CSV 作为逐条进度源）：
- 读取/校验 CSV（确定执行边界）
- 循环处理 issues（逐条闭环提交）
- 汇总交接（完成条数/阻塞点/后续建议）

## 三、输入与选择 issue 规则

1. `$ARGUMENTS` 必须提供一个 issues CSV 路径（相对/绝对均可）。
   - **唯一状态源**：你必须把“用户传入的这一个 CSV 文件”当作唯一状态源与提交对象；只读写/提交这一份 CSV。
   - **禁止擅自新建/同步**：不要创建/更新 `issues/issues.csv` 或任何其它“汇总/快照 CSV”，除非用户明确要求（且目标文件就是用户传入的那份）。
2. **“完成”判定（用于决定是否还要继续循环）**：
   - 仅当该行同时满足：`dev_state=已完成`、`review_initial_state=已完成`、`review_regression_state=已完成`、`git_state=已提交`，才视为“闭环完成”。        
   - 若采用受限验收：允许将 `review_regression_state` 置为 `已完成`，但 `notes` 必须包含 `validation_limited:` 与 `manual_test:`，并在交接中说明。
3. **每轮选择一行的规则（顺序由你决定，但要可解释）**：
   - 先收敛半成品：若存在 `git_state=未提交` 且（`dev_state=进行中` 或 `dev_state=已完成`）的行，优先从这些行里选一条先完成提交（避免长期悬挂）。
   - 再选可交付项：在其余“未闭环完成”的行中，自主决定下一条（建议顺序：P0 → P1 → P2；优先能解阻塞/提供公共能力的任务；尽量减少无意义的上下文切换）。
   - 选中后需给出 1 句话理由（写入该行 `notes`，例如 `picked_reason:<...>`），便于回溯为什么这么排。
4. **阻塞策略（允许跳过，但必须回收）**：
   - 单条 issue 若出现“硬阻塞”（需要用户决策/外部环境/权限/凭证）：按「五、失败/阻塞处理」落盘后，允许切到下一条继续推进。
   - 当所有剩余未闭环完成的 issues 都处于阻塞状态，或连续多条遇到硬阻塞导致无法推进：停止并汇总阻塞清单，向用户请求最小必要信息。

## 四、执行闭环

按顺序执行以下步骤（每一步都要用工具实际落盘/验证，不要“想象完成”）：

0. **接收与现实检查 + 建立执行计划（update_plan）**
   - 用 1–2 句话重述：本轮执行的 CSV 路径、当前要处理的 `id/title`、验收口径、风险点（如有）。
   - 用 `update_plan` 建立并追踪本轮执行计划（建议 3 步：读取/校验 CSV → 循环处理 issues → 汇总交接），循环中不要反复重建计划（细粒度进度以 CSV 状态为准）。
1. **读取 CSV + 校验表头**
   - 必须包含固定表头（与 `/openspec_to_issues_csv` 一致）：
     `id,priority,phase,area,title,description,acceptance_criteria,test_mcp,review_initial_requirements,review_regression_requirements,dev_state,review_initial_state,review_regression_state,git_state,owner,refs,notes`
   - 不符合则停止，并提示用户先用 `/openspec_to_issues_csv <change-id>` 生成/修复 CSV。
   - 快照策略：日常推进只维护用户本次传入的 CSV 文件；不要自动新建 `issues/YYYY-...csv`，除非用户明确要求或属于“从 Plan 初始化生成/会议大改重落盘”。
   - 汇总策略：不要自动生成/更新 `issues/issues.csv`（除非用户传入的就是该文件）。
2. **锁定目标行并输出摘要**
   - 输出：`id/title/description/acceptance_criteria/test_mcp/refs`（简洁即可）。
3. **补齐执行信息（如缺失）**
   - `acceptance_criteria` 必须可验证（最好给复现步骤/阈值）。
   - `review_initial_requirements` 与 `review_regression_requirements` 必须可执行（兼容性/边界/回归点）。
   - `test_mcp` 必须明确（`AUTOSERVER|AUTOFRONTEND|AUTOE2E|CONTRACT|MIGRATION|MANUAL` 或项目自定义枚举）。
   - `refs` 至少 1 个 `path:line`（指向入口文件/关键函数）。
   - 若需要变更这些字段：**先写入 CSV 再继续编码**。
4. **启动状态并写回 CSV**
   - 将该行 `dev_state` 置为 `进行中`；
   - 将该行 `review_initial_state` 置为 `进行中`（代表边开发边 Review 已开始）；
   - 保存 CSV（保持 **UTF-8 BOM**；若 Excel/WPS 占用导致写入失败，提示用户关闭占用进程后重试）。
5. **上下文收集（最小必要）**
   - 优先从 `refs` 指向文件开始读；
   - 使用 `rg` 精确定位关键符号与调用链；
   - 早停：能明确“要改哪些具体文件/函数”即可进入实现。
6. **实现（重点：按验收口径驱动） + 文档同步**
   1. **实现前确认**
      - 把 `acceptance_criteria` 拆成“可验证的最小变更集合”（优先 1–3 个可测点）；若拆不开，先把验收口径补齐再写代码。
      - 明确改动边界：本次只覆盖该 issue；如发现需要拆分为多个 issue，先在 CSV 落盘再继续。
   2. **最小变更设计（KISS/YAGNI/兼容优先）**
      - 复用项目既有模式与抽象；避免引入新架构/新依赖。
      - 未经批准不破坏现有 API/CLI/数据格式；必要时加兼容分支/降级逻辑，并在 `notes` 记录理由。
   3. **编码执行（质量门前移）**
      - 单一职责：函数只做一件事；控制嵌套层级（尽量 ≤3）。
      - 错误处理与可观测性：关键失败路径要有明确返回/异常处理与日志（避免泄露敏感信息）。
      - 性能与资源：避免明显的 O(N^2)/全表扫描/无界缓存/无界重试；对外部依赖设置超时与降级（如适用）。
      - 改动习惯：小步提交前先 `git diff` 自查边界，避免把无关格式化/重命名混进来。
   4. **实现内循环验证**
      - 在实现过程中就运行最相关的检查/测试（而不是最后一次性跑）；失败要先修再推进状态。
      - 需要时补充最小必要的测试用例（项目已有测试体系时）；不要给无测试项目强行引入新框架。
   5. **文档/refs 同步（与实现同等重要）**
      - 同步更新与该 issue 直接相关的文档/注释/验收记录（以 `acceptance_criteria` 为准）。
      - 若新增/修改关键入口或关键行为变化：把新的 `path:line` 追加到该行 `refs`（用 `;` 分隔）。
7. **Review（两段式）**
   - 对照 `review_initial_requirements` 完成开发过程自查，并将 `review_initial_state` 置为 `已完成`；
   - 对照 `review_regression_requirements` 执行回归/复测，并将 `review_regression_state` 置为 `已完成`。
   - 若回归/复测在当前环境不可执行：走“受限验收”（按「一-7」写 `notes` + 交接说明），仍可将 `review_regression_state` 置为 `已完成`，但不得声称测试通过。
8. **自我验收（严格按 acceptance_criteria）**
   - 给出“通过/未通过”的证据；
   - 按 `test_mcp` 运行最相关的测试/检查（例如：后端 pytest、前端 lint/test、e2e playwright 等）。
   - 若无法运行测试：按「一-7」记录 `notes`（含 `manual_test` 与 `risk`），并补充最小可行的替代验证；交接中明确哪些未跑。
9. **完成状态并写回 CSV（提交前，确保同 commit 演进）**
   - 将该行 `dev_state` 置为 `已完成`；
   - 将该行 `git_state` 置为 `已提交`（表示“本次将完成本地提交”；若后续提交失败，需回滚为 `未提交` 再重试）；
   - `notes` 追加：`done_at:<date>`、验收要点/证据摘要、（可选）`pr:<id>`；
   - 保存 CSV（保持 UTF-8 BOM）。
10. **Git 提交（闭环关键步骤）**
   - `git status` / `git diff` 确认变更边界只覆盖该 issue（无关改动要剔除）。
   - `git add` 必须包含：代码变更 + 当前 CSV 文件（同 commit 演进）。
   - 提交粒度：优先“一条 issue 一个 commit/PR”。
   - commit message：`[<id>] <title>`（必要时补充短说明）。
   - 可选追溯：如果必须把 commit hash 写进 CSV 的 `notes`，只能“提交后再更新 CSV 再提交一次”（会产生 meta commit）；否则把 hash 写在对话交接输出里即可。
   - 若 `git commit` 失败：必须将该行 `git_state` 回滚为 `未提交`，在 `notes` 记录 `blocked:git commit failed <原因>`，并停止（不要继续下一条）。
11. **对话交接输出（按 AGENTS 执行进度式，简洁）**
   - 本次处理的 `id/title`；
   - 若本次循环处理了多条：输出“本次完成条数 / 剩余未完成条数 /（如有）阻塞 id”；
   - 关键变更点与文件引用（`path:line`）；
   - 实际运行的测试/结果；
   - 若采用受限验收：列出未运行测试/原因/`manual_test`；
   - 本地 commit hash（如果已提交）；
   - 风险/后续建议（若有）。
12. **循环与停止条件（默认循环）**
   - 每完成并提交一条后，回到「三、输入与选择 issue 规则」选择下一条继续，直到：
     - 所有 issues 均达到“闭环完成”；或
     - 所有剩余 issues 均阻塞，无法继续推进（按「五、失败/阻塞处理」汇总后停止）。

## 五、失败/阻塞处理（必须落盘）

出现以下任一情况，优先尝试自行消化；若确实无法在当前上下文内解决，则按本节“落盘阻塞”处理：

特别说明：测试“无法运行”不等同于阻塞。若实现已完成且风险可控，优先走“受限验收”（按「一-7」记录 `notes`）并提交；只有当跳过测试会带来高风险（例如数据迁移/权限/支付/删除/大范围重构）时，才按本节阻塞处理。

- 验收口径不清；
- refs 找不到/代码定位失败；
- 测试失败且无法在当前上下文修复；
- 需要改动超出该行 `description` 边界。

处理方式：

1. 在该行 `notes` 记录：`blocked:<原因>` + 已做过的排查/下一步建议；
2. `dev_state/review_*_state` 保持“真实进度”（通常为 `进行中`；若实现与验收已完成但卡在提交/回归，可为 `已完成`），但 `git_state` 必须保持 `未提交`；
3. 继续策略：
   - 若还有其他不依赖该阻塞项的 issues：允许继续下一条推进（但在最终交接必须汇总阻塞清单）。
   - 若剩余 issues 全部阻塞：停止并用 1–3 句话向用户汇报阻塞点与需要的最小决策信息。

## 六、使用示例

- `/issues_csv_execute issues/2026-01-09_14-30-00-add-l2-updater.csv`
- `/issues_csv_execute issues\2026-01-09_09-15-22-memory-refactor.csv`  (Windows)

> 上游生成：`/openspec_to_issues_csv <change-id>`

## 七、提交前自检清单

**闭环必过**：
- 该 issue 的验收口径有“可复现证据”（测试输出/复现步骤/截图路径等）
- 若采用受限验收：该行 `notes` 已写 `validation_limited/manual_test/evidence/risk`，且交接明确未跑项
- `review_initial_state` 与 `review_regression_state` 已按要求推进（Review 双轨不互相替代）
- CSV 与代码一起提交（`git add` 覆盖两者），且状态枚举值合法
- 文档/注释/refs 已与实现同步（最小但准确）
- commit message 以 `[<id>] <title>` 开头且无无关改动

**<self_reflection> 质量自评**：
- 可维护性（改动可读、可定位、易回滚）
- 测试覆盖（新增/更新关键测试或在 `notes` 说明为何无法补）
- 性能（避免明显退化；必要时补最小测量/对比）
- 安全性（不泄露敏感信息；输入校验/权限边界不倒退）
- 代码风格（遵循项目既有风格；避免无关格式化/重命名）
- 文档（与行为一致；验收口径/用法/限制写清楚）
- 向后兼容性（不破坏现有 API/CLI/数据格式；必要时有兼容策略）

**流程自检（AGENTS）**：
- 接触工具前已记录“接收与现实检查”
- 首次上下文收集在 5–8 次工具调用内（或已在 `notes` 记录例外原因）
- 使用 `update_plan` 追踪 ≥2 步且实时更新（不批量更新）
- 交接输出包含 `path:line`、风险与后续步骤
